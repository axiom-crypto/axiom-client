"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBeaconSubquery = exports.validateSolidityNestedMappingSubquery = exports.validateReceiptSubquery = exports.validateTxSubquery = exports.validateStorageSubquery = exports.validateAccountSubquery = exports.validateHeaderSubquery = void 0;
const ethers_1 = require("ethers");
const tools_1 = require("@axiom-crypto/tools");
async function validateHeaderSubquery(provider, subquery) {
    if ((subquery.fieldIdx > tools_1.HeaderField.WithdrawalsRoot && subquery.fieldIdx < tools_1.AxiomV2FieldConstant.Header.HashFieldIdx) ||
        (subquery.fieldIdx > tools_1.AxiomV2FieldConstant.Header.ExtraDataLenFieldIdx &&
            subquery.fieldIdx < tools_1.AxiomV2FieldConstant.Header.LogsBloomFieldIdxOffset) ||
        subquery.fieldIdx >= tools_1.AxiomV2FieldConstant.Header.LogsBloomFieldIdxOffset + 8) {
        console.error(`Invalid header field index: ${subquery.fieldIdx}`);
        return false;
    }
    const latestBlock = await provider.getBlock("latest");
    if (latestBlock === null) {
        throw new Error("Failed to get latest block; check your internet connection or provider RPC");
    }
    if (subquery.blockNumber > latestBlock.number) {
        console.warn(`Block number ${subquery.blockNumber} is in the future`);
    }
    const value = await (0, tools_1.getHeaderFieldValue)(provider, subquery, console);
    if (value === null) {
        console.error(`Header subquery ${JSON.stringify(subquery)} returned null`);
        return false;
    }
    return true;
}
exports.validateHeaderSubquery = validateHeaderSubquery;
async function validateAccountSubquery(provider, subquery) {
    if (subquery.fieldIdx > tools_1.AccountField.CodeHash) {
        console.error(`Invalid account field index: ${subquery.fieldIdx}`);
        return false;
    }
    const latestBlock = await provider.getBlock("latest");
    if (latestBlock === null) {
        throw new Error("Failed to get latest block; check your internet connection or provider RPC");
    }
    if (subquery.blockNumber > latestBlock.number) {
        console.warn(`Block number ${subquery.blockNumber} is in the future`);
    }
    const value = await (0, tools_1.getAccountFieldValue)(provider, subquery, console);
    if (value === null) {
        console.error(`Account subquery ${JSON.stringify(subquery)} returned null`);
        return false;
    }
    return true;
}
exports.validateAccountSubquery = validateAccountSubquery;
async function validateStorageSubquery(provider, subquery) {
    const latestBlock = await provider.getBlock("latest");
    if (latestBlock === null) {
        throw new Error("Failed to get latest block; check your internet connection or provider RPC");
    }
    if (subquery.blockNumber > latestBlock.number) {
        console.warn(`Block number ${subquery.blockNumber} is in the future`);
    }
    const value = await (0, tools_1.getStorageFieldValue)(provider, subquery, console);
    if (value === null) {
        console.error(`Storage subquery ${JSON.stringify(subquery)} returned null`);
        return false;
    }
    return true;
}
exports.validateStorageSubquery = validateStorageSubquery;
async function validateTxSubquery(provider, subquery, configLimitManager) {
    if ((subquery.fieldOrCalldataIdx > tools_1.TxField.s && subquery.fieldOrCalldataIdx < tools_1.AxiomV2FieldConstant.Tx.TxTypeFieldIdx) ||
        (subquery.fieldOrCalldataIdx > tools_1.AxiomV2FieldConstant.Tx.CalldataHashFieldIdx &&
            subquery.fieldOrCalldataIdx < tools_1.AxiomV2FieldConstant.Tx.CalldataIdxOffset)) {
        console.error(`Invalid tx field/calldata index: ${subquery.fieldOrCalldataIdx}`);
        return false;
    }
    const tx = await (0, tools_1.getRawTransaction)(provider, subquery.txHash);
    if (!tx) {
        console.error(`Unable to get transaction from txHash: ${subquery.txHash}`);
        return false;
    }
    if (tx.blockNumber === undefined || tx.transactionIndex === undefined) {
        console.error("Unable to get blockNumber or txIdx from supplied txHash");
        return false;
    }
    const blockNumber = Number(tx.blockNumber);
    const txIdx = Number(tx.transactionIndex);
    configLimitManager.processTx(tx);
    const value = await (0, tools_1.getTxFieldValue)(provider, {
        blockNumber,
        txIdx,
        fieldOrCalldataIdx: subquery.fieldOrCalldataIdx,
    }, console, tx);
    if (value === null) {
        console.error(`Tx subquery ${JSON.stringify(subquery)} returned null`);
        return false;
    }
    return true;
}
exports.validateTxSubquery = validateTxSubquery;
async function validateReceiptSubquery(provider, subquery, configLimitManager) {
    if ((subquery.fieldOrLogIdx > tools_1.ReceiptField.CumulativeGas &&
        subquery.fieldOrLogIdx < tools_1.AxiomV2FieldConstant.Receipt.AddressIdx) ||
        (subquery.fieldOrLogIdx > tools_1.AxiomV2FieldConstant.Receipt.TxIndexFieldIdx &&
            subquery.fieldOrLogIdx < tools_1.AxiomV2FieldConstant.Receipt.LogIdxOffset)) {
        console.error(`Invalid receipt field/log index: ${subquery.fieldOrLogIdx}`);
        return false;
    }
    if (subquery.fieldOrLogIdx >= tools_1.AxiomV2FieldConstant.Receipt.LogIdxOffset) {
        if (!ethers_1.ethers.isBytesLike(subquery.eventSchema) || (0, tools_1.getNumBytes)(subquery.eventSchema) !== 32) {
            console.error(`Must define event schema when using log index: ${subquery.eventSchema}`);
            return false;
        }
    }
    if (subquery.topicOrDataOrAddressIdx > 4 &&
        subquery.topicOrDataOrAddressIdx < tools_1.AxiomV2FieldConstant.Receipt.LogIdxOffset &&
        subquery.topicOrDataOrAddressIdx !== tools_1.AxiomV2FieldConstant.Receipt.AddressIdx) {
        console.error(`Invalid receipt topic/data/address index index: ${subquery.topicOrDataOrAddressIdx}`);
        return false;
    }
    const rc = await (0, tools_1.getRawReceipt)(provider, subquery.txHash);
    if (!rc) {
        console.error(`Unable to get receipt from txHash: ${subquery.txHash}`);
        return false;
    }
    if (rc.blockNumber === undefined || rc.transactionIndex === undefined) {
        console.error("Unable to get blockNumber or txIdx from supplied txHash");
        return false;
    }
    const blockNumber = Number(rc.blockNumber);
    const txIdx = Number(rc.transactionIndex);
    configLimitManager.processReceipt(rc);
    const value = await (0, tools_1.getReceiptFieldValue)(provider, {
        blockNumber,
        txIdx,
        fieldOrLogIdx: subquery.fieldOrLogIdx,
        topicOrDataOrAddressIdx: subquery.topicOrDataOrAddressIdx,
        eventSchema: subquery.eventSchema,
    }, console, rc);
    if (value === null) {
        console.error(`Receipt subquery ${JSON.stringify(subquery)} returned null`);
        return false;
    }
    return true;
}
exports.validateReceiptSubquery = validateReceiptSubquery;
async function validateSolidityNestedMappingSubquery(provider, subquery) {
    if (subquery.keys.length !== subquery.mappingDepth) {
        console.error(`Nested mapping keys length ${subquery.keys.length} does not match mapping depth ${subquery.mappingDepth}`);
        return false;
    }
    const latestBlock = await provider.getBlock("latest");
    if (latestBlock === null) {
        throw new Error("Failed to get latest block; check your internet connection or provider RPC");
    }
    if (subquery.blockNumber > latestBlock.number) {
        console.warn(`Block number ${subquery.blockNumber} is in the future`);
    }
    for (const key of subquery.keys) {
        if (!ethers_1.ethers.isBytesLike(key)) {
            console.error(`Invalid nested mapping key: ${key} (must be bytes-like)`);
            return false;
        }
    }
    const value = await (0, tools_1.getSolidityNestedMappingValue)(provider, subquery, console);
    if (value === null) {
        console.error(`Solidity nested mapping subquery ${JSON.stringify(subquery)} returned null`);
        return false;
    }
    return true;
}
exports.validateSolidityNestedMappingSubquery = validateSolidityNestedMappingSubquery;
async function validateBeaconSubquery(provider, subquery) {
    // WIP
    return true;
}
exports.validateBeaconSubquery = validateBeaconSubquery;
//# sourceMappingURL=validate.js.map