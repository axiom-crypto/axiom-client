/* tslint:disable */
/* eslint-disable */
/**
*/
export function initPanicHook(): void;
export interface CircuitStats {
    advice: number;
    lookup: number;
    fixed: number;
    instance: number;
    k: number;
}

export interface CircuitConfig {
    k: number;
    numAdvice: number;
    numLookupAdvice: number;
    numInstance: number;
    numLookupBits: number;
    numVirtualInstance: number;
}

/**
*/
export class Bn254Fq2Point {
  free(): void;
/**
* @returns {Bn254FqPoint}
*/
  c0(): Bn254FqPoint;
/**
* @returns {Bn254FqPoint}
*/
  c1(): Bn254FqPoint;
}
/**
* We use 3 limbs with 88 bits each.
* NOT constrained to be less than the prime.
*/
export class Bn254FqPoint {
  free(): void;
/**
* @param {Halo2LibWasm} lib_wasm
* @returns {JsCircuitValue256}
*/
  to_circuit_value_256(lib_wasm: Halo2LibWasm): JsCircuitValue256;
}
/**
*/
export class Bn254G1AffinePoint {
  free(): void;
/**
* @returns {Bn254FqPoint}
*/
  x(): Bn254FqPoint;
/**
* @returns {Bn254FqPoint}
*/
  y(): Bn254FqPoint;
}
/**
*/
export class Bn254G2AffinePoint {
  free(): void;
/**
* @returns {Bn254Fq2Point}
*/
  x(): Bn254Fq2Point;
/**
* @returns {Bn254Fq2Point}
*/
  y(): Bn254Fq2Point;
}
/**
*/
export class Halo2LibWasm {
  free(): void;
/**
* @param {Halo2Wasm} circuit
*/
  constructor(circuit: Halo2Wasm);
/**
*/
  config(): void;
/**
* @param {number} a
* @param {number} b
* @returns {number}
*/
  add(a: number, b: number): number;
/**
* @param {number} a
* @param {number} b
* @returns {number}
*/
  sub(a: number, b: number): number;
/**
* @param {number} a
* @returns {number}
*/
  neg(a: number): number;
/**
* @param {number} a
* @param {number} b
* @returns {number}
*/
  mul(a: number, b: number): number;
/**
* @param {number} a
* @param {number} b
* @param {number} c
* @returns {number}
*/
  mul_add(a: number, b: number, c: number): number;
/**
* @param {number} a
* @param {number} b
* @returns {number}
*/
  mul_not(a: number, b: number): number;
/**
* @param {number} a
*/
  assert_bit(a: number): void;
/**
* @param {number} a
* @param {number} b
* @returns {number}
*/
  div_unsafe(a: number, b: number): number;
/**
* @param {number} a
* @param {string} b
*/
  assert_is_const(a: number, b: string): void;
/**
* @param {Uint32Array} a
* @param {Uint32Array} b
* @returns {number}
*/
  inner_product(a: Uint32Array, b: Uint32Array): number;
/**
* @param {Uint32Array} a
* @returns {number}
*/
  sum(a: Uint32Array): number;
/**
* @param {number} a
* @param {number} b
* @returns {number}
*/
  and(a: number, b: number): number;
/**
* @param {number} a
* @param {number} b
* @returns {number}
*/
  or(a: number, b: number): number;
/**
* @param {number} a
* @returns {number}
*/
  not(a: number): number;
/**
* @param {number} a
* @returns {number}
*/
  dec(a: number): number;
/**
* @param {number} a
* @param {number} b
* @param {number} sel
* @returns {number}
*/
  select(a: number, b: number, sel: number): number;
/**
* @param {number} a
* @param {number} b
* @param {number} c
* @returns {number}
*/
  or_and(a: number, b: number, c: number): number;
/**
* @param {Uint32Array} a
* @returns {Uint32Array}
*/
  bits_to_indicator(a: Uint32Array): Uint32Array;
/**
* @param {number} a
* @param {string} b
* @returns {Uint32Array}
*/
  idx_to_indicator(a: number, b: string): Uint32Array;
/**
* @param {Uint32Array} a
* @param {Uint32Array} indicator
* @returns {number}
*/
  select_by_indicator(a: Uint32Array, indicator: Uint32Array): number;
/**
* @param {Uint32Array} a
* @param {number} idx
* @returns {number}
*/
  select_from_idx(a: Uint32Array, idx: number): number;
/**
* @param {number} a
* @returns {number}
*/
  is_zero(a: number): number;
/**
* @param {number} a
* @param {number} b
* @returns {number}
*/
  is_equal(a: number, b: number): number;
/**
* @param {number} a
* @param {string} num_bits
* @returns {Uint32Array}
*/
  num_to_bits(a: number, num_bits: string): Uint32Array;
/**
* @param {number} a
* @param {number} b
*/
  constrain_equal(a: number, b: number): void;
/**
* @param {number} a
* @param {string} b
*/
  range_check(a: number, b: string): void;
/**
* @param {number} a
* @param {number} b
* @param {string} size
*/
  check_less_than(a: number, b: number, size: string): void;
/**
* @param {number} a
* @param {string} b
*/
  check_less_than_safe(a: number, b: string): void;
/**
* @param {number} a
* @param {number} b
* @param {string} size
* @returns {number}
*/
  is_less_than(a: number, b: number, size: string): number;
/**
* @param {number} a
* @param {string} b
* @returns {number}
*/
  is_less_than_safe(a: number, b: string): number;
/**
* @param {number} a
* @param {string} b
* @param {string} size
* @returns {Uint32Array}
*/
  div_mod(a: number, b: string, size: string): Uint32Array;
/**
* Returns a 256-bit hi-lo pair from a single CircuitValue
* 
* See `check_hi_lo` for what is constrained.
* 
* * `a`: the CircuitValue to split into hi-lo
* @param {number} a
* @returns {Uint32Array}
*/
  to_hi_lo(a: number): Uint32Array;
/**
* Returns a single CircuitValue from a hi-lo pair
* 
* NOTE: this can fail if the hi-lo pair is greater than the Fr modulus.
* See `check_hi_lo` for what is constrained.
* 
* * `hi`: the high 128 bits of the CircuitValue
* * `lo`: the low 128 bits of the CircuitValue
* @param {number} hi
* @param {number} lo
* @returns {number}
*/
  from_hi_lo(hi: number, lo: number): number;
/**
* @param {number} a
* @param {number} b
* @param {string} a_size
* @param {string} b_size
* @returns {Uint32Array}
*/
  div_mod_var(a: number, b: number, a_size: string, b_size: string): Uint32Array;
/**
* @param {number} a
* @param {number} b
* @param {string} max_bits
* @returns {number}
*/
  pow_var(a: number, b: number, max_bits: string): number;
/**
* @param {Uint32Array} a
* @returns {number}
*/
  poseidon(a: Uint32Array): number;
/**
* @param {string} val
* @returns {number}
*/
  witness(val: string): number;
/**
* @param {string} val
* @returns {number}
*/
  constant(val: string): number;
/**
* @param {Halo2Wasm} circuit
* @param {number} a
* @param {number} col
*/
  make_public(circuit: Halo2Wasm, a: number, col: number): void;
/**
* @param {Halo2Wasm} circuit
* @param {number} a
*/
  log(circuit: Halo2Wasm, a: number): void;
/**
* @param {number} a
* @returns {string}
*/
  value(a: number): string;
/**
* @returns {number}
*/
  lookup_bits(): number;
/**
* Takes in CircuitValue256 in hi-lo form and loads internal CircuitBn254Fq type (we use 3 limbs of 88 bits).
* This function does not range check `hi,lo` to be `uint128` in case it's already done elsewhere.
* @param {JsCircuitValue256} val
* @returns {Bn254FqPoint}
*/
  load_bn254_fq(val: JsCircuitValue256): Bn254FqPoint;
/**
* Doesn't range check limbs of g1_point.
* Does not allow you to load identity point.
* @param {JsCircuitBn254G1Affine} point
* @returns {Bn254G1AffinePoint}
*/
  load_bn254_g1(point: JsCircuitBn254G1Affine): Bn254G1AffinePoint;
/**
* `g1_points` should be array of `CircuitBn254G1Affine` in hi-lo form.
* This function does not range check `hi,lo` to be `uint128` in case it's already done elsewhere.
* Prevents any g1_points from being identity.
* @param {Array<any>} g1_points
* @returns {Bn254G1AffinePoint}
*/
  bn254_g1_sum(g1_points: Array<any>): Bn254G1AffinePoint;
/**
* `g1_point_1` and `g1_point_2` are `CircuitBn254G1Affine` points in hi-lo form.
* This function does not range check `hi,lo` to be `uint128` in case it's already done elsewhere
* and also it constraints that g1_point_1.x != g1_point_2.x
* Prevents any g1_points from being identity.
* @param {JsCircuitBn254G1Affine} g1_point_1
* @param {JsCircuitBn254G1Affine} g1_point_2
* @returns {Bn254G1AffinePoint}
*/
  bn254_g1_sub_unequal(g1_point_1: JsCircuitBn254G1Affine, g1_point_2: JsCircuitBn254G1Affine): Bn254G1AffinePoint;
/**
* Doesn't range check limbs of g2_point.
* Does not allow you to load identity point.
* @param {JsCircuitBn254G2Affine} point
* @returns {Bn254G2AffinePoint}
*/
  load_bn254_g2(point: JsCircuitBn254G2Affine): Bn254G2AffinePoint;
/**
* `g2_points` should be array of `CircuitBn254G2Affine` in hi-lo form.
* This function does not range check `hi,lo` to be `uint128` in case it's already done elsewhere.
* Prevents any g2_points from being identity.
* @param {Array<any>} g2_points
* @returns {Bn254G2AffinePoint}
*/
  bn254_g2_sum(g2_points: Array<any>): Bn254G2AffinePoint;
/**
* Verifies that e(lhs_g1, lhs_g2) = e(rhs_g1, rhs_g2) by checking e(lhs_g1, lhs_g2)*e(-rhs_g1, rhs_g2) === 1
* Returns [CircuitValue] for the result as a boolean (1 if signature verification is successful).
* None of the points should be identity.
* @param {Bn254G1AffinePoint} lhs_g1
* @param {Bn254G2AffinePoint} lhs_g2
* @param {Bn254G1AffinePoint} rhs_g1
* @param {Bn254G2AffinePoint} rhs_g2
* @returns {number}
*/
  bn254_pairing_check(lhs_g1: Bn254G1AffinePoint, lhs_g2: Bn254G2AffinePoint, rhs_g1: Bn254G1AffinePoint, rhs_g2: Bn254G2AffinePoint): number;
/**
* Doesn't range check limbs of point.
* Pubkey is a point on
* @param {JsCircuitSecp256k1Affine} point
* @returns {Secp256k1AffinePoint}
*/
  load_secp256k1_pubkey(point: JsCircuitSecp256k1Affine): Secp256k1AffinePoint;
/**
* Assumes all `JsCircuitValue256` limbs have been range checked to be `u128`.
* @param {Secp256k1AffinePoint} pubkey
* @param {JsCircuitValue256} r
* @param {JsCircuitValue256} s
* @param {JsCircuitValue256} msg_hash
* @returns {number}
*/
  verify_secp256k1_ecdsa_signature(pubkey: Secp256k1AffinePoint, r: JsCircuitValue256, s: JsCircuitValue256, msg_hash: JsCircuitValue256): number;
/**
* @param {bigint} sk
* @param {bigint} msg_hash
* @param {bigint} k
* @returns {number}
*/
  ecdsa_benchmark(sk: bigint, msg_hash: bigint, k: bigint): number;
/**
* @param {number} hi
* @param {number} lo
* @returns {JsCircuitValue256}
*/
  to_js_circuit_value_256(hi: number, lo: number): JsCircuitValue256;
/**
* @param {JsCircuitValue256} x
* @param {JsCircuitValue256} y
* @returns {JsCircuitBn254G1Affine}
*/
  to_js_circuit_bn254_g1_affine(x: JsCircuitValue256, y: JsCircuitValue256): JsCircuitBn254G1Affine;
/**
* @param {JsCircuitValue256} c0
* @param {JsCircuitValue256} c1
* @returns {JsCircuitBn254Fq2}
*/
  to_js_circuit_bn254_fq2(c0: JsCircuitValue256, c1: JsCircuitValue256): JsCircuitBn254Fq2;
/**
* @param {JsCircuitBn254Fq2} x
* @param {JsCircuitBn254Fq2} y
* @returns {JsCircuitBn254G2Affine}
*/
  to_js_circuit_bn254_g2_affine(x: JsCircuitBn254Fq2, y: JsCircuitBn254Fq2): JsCircuitBn254G2Affine;
/**
* @param {JsCircuitValue256} x
* @param {JsCircuitValue256} y
* @returns {JsCircuitSecp256k1Affine}
*/
  to_js_circuit_secp256k1_affine(x: JsCircuitValue256, y: JsCircuitValue256): JsCircuitSecp256k1Affine;
}
/**
*/
export class Halo2Wasm {
  free(): void;
/**
*/
  constructor();
/**
*/
  clear(): void;
/**
*/
  clearInstances(): void;
/**
* @param {Uint8Array} proof
*/
  verify(proof: Uint8Array): void;
/**
* @param {number} col
* @returns {Uint32Array}
*/
  getInstances(col: number): Uint32Array;
/**
* @param {Uint32Array} instances
* @param {number} col
*/
  setInstances(instances: Uint32Array, col: number): void;
/**
* @param {number} col
* @returns {any}
*/
  getInstanceValues(col: number): any;
/**
* @param {CircuitConfig} config
*/
  config(config: CircuitConfig): void;
/**
* @returns {CircuitStats}
*/
  getCircuitStats(): CircuitStats;
/**
* @returns {Uint8Array}
*/
  getVk(): Uint8Array;
/**
* @returns {Uint8Array}
*/
  getPartialVk(): Uint8Array;
/**
* @returns {Uint8Array}
*/
  getPk(): Uint8Array;
/**
*/
  assignInstances(): void;
/**
*/
  mock(): void;
/**
* @param {Uint8Array} params
*/
  loadParams(params: Uint8Array): void;
/**
* @param {Uint8Array} vk
*/
  loadVk(vk: Uint8Array): void;
/**
* @param {Uint8Array} pk
*/
  loadPk(pk: Uint8Array): void;
/**
*/
  genVk(): void;
/**
*/
  genPk(): void;
/**
* @returns {Uint8Array}
*/
  prove(): Uint8Array;
/**
* For console logging only.
* @param {string} a
*/
  log(a: string): void;
}
/**
*/
export class JsCircuitBn254Fq2 {
  free(): void;
/**
* @param {JsCircuitValue256} c0
* @param {JsCircuitValue256} c1
*/
  constructor(c0: JsCircuitValue256, c1: JsCircuitValue256);
/**
*/
  c0: JsCircuitValue256;
/**
*/
  c1: JsCircuitValue256;
}
/**
*/
export class JsCircuitBn254G1Affine {
  free(): void;
/**
* @param {JsCircuitValue256} x
* @param {JsCircuitValue256} y
*/
  constructor(x: JsCircuitValue256, y: JsCircuitValue256);
/**
*/
  x: JsCircuitValue256;
/**
*/
  y: JsCircuitValue256;
}
/**
*/
export class JsCircuitBn254G2Affine {
  free(): void;
/**
* @param {JsCircuitBn254Fq2} x
* @param {JsCircuitBn254Fq2} y
*/
  constructor(x: JsCircuitBn254Fq2, y: JsCircuitBn254Fq2);
/**
*/
  x: JsCircuitBn254Fq2;
/**
*/
  y: JsCircuitBn254Fq2;
}
/**
*/
export class JsCircuitSecp256k1Affine {
  free(): void;
/**
* @param {JsCircuitValue256} x
* @param {JsCircuitValue256} y
*/
  constructor(x: JsCircuitValue256, y: JsCircuitValue256);
/**
*/
  x: JsCircuitValue256;
/**
*/
  y: JsCircuitValue256;
}
/**
* When this type is used, it is **ASSUMED** that the corresponding `hi,lo` [AssignedValue]s have been range checked to be 128 bits each.
*/
export class JsCircuitValue256 {
  free(): void;
/**
* @param {number} hi
* @param {number} lo
*/
  constructor(hi: number, lo: number);
/**
*/
  hi: number;
/**
*/
  lo: number;
}
/**
*/
export class Secp256k1AffinePoint {
  free(): void;
/**
* @returns {Secp256k1FpPoint}
*/
  x(): Secp256k1FpPoint;
/**
* @returns {Secp256k1FpPoint}
*/
  y(): Secp256k1FpPoint;
}
/**
* We use 3 limbs with 88 bits each.
* NOT constrained to be less than the prime.
*/
export class Secp256k1FpPoint {
  free(): void;
/**
* @param {Halo2LibWasm} lib_wasm
* @returns {JsCircuitValue256}
*/
  to_circuit_value_256(lib_wasm: Halo2LibWasm): JsCircuitValue256;
}
/**
* We use 3 limbs with 88 bits each.
* NOT constrained to be less than the prime.
*/
export class Secp256k1FqPoint {
  free(): void;
/**
* @param {Halo2LibWasm} lib_wasm
* @returns {JsCircuitValue256}
*/
  to_circuit_value_256(lib_wasm: Halo2LibWasm): JsCircuitValue256;
}
