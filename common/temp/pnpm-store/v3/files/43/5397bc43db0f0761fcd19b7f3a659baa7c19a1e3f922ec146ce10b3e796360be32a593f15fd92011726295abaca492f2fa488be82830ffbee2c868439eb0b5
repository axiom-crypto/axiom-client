import { AxiomV2Callback, AxiomV2ComputeQuery, AxiomV2DataQuery, AxiomV2FeeData, AxiomV2Result, DataSubquery, DataSubqueryType } from "./types";
/**
 * Encodes a v2 Query as a hex string
 * @param sourceChainId
 * @param caller
 * @param dataQueryHash
 * @param computeQuery
 * @param callback
 * @param feeData
 * @param userSalt
 * @param refundee
 * @returns data encoded as hex string of bytes
 */
export declare function encodeQueryV2(sourceChainId: number | string | BigInt, caller: string, dataQueryHash: string, computeQuery: AxiomV2ComputeQuery, callback: AxiomV2Callback, feeData: AxiomV2FeeData, userSalt: string, refundee: string): string;
/**
 * Encodes the full AxiomV2Query that can be fully decoded later
 *
 */
export declare function encodeFullQueryV2(sourceChainId: number | string | BigInt, caller: string, dataQuery: AxiomV2DataQuery, computeQuery: AxiomV2ComputeQuery, callback: AxiomV2Callback, feeData: AxiomV2FeeData, userSalt: string, refundee: string): string;
/**
 * Computes the query hash for a v2 query:
 *   queryHash = keccak(version . sourceChainId . dataQueryHash . computeQuery)
 * @param sourceChainId
 * @param dataQueryHash
 * @param computeQuery
 * @returns query hash as hex string of bytes
 */
export declare function getQueryHashV2(sourceChainId: number | string | BigInt, dataQueryHash: string, computeQuery: AxiomV2ComputeQuery): string;
/**
 * Calculates the queryId:
 *   queryId = keccak(targetChainId . caller . userSalt . queryHash . callbackHash . refundee)
 */
export declare function getQueryId(targetChainId: string, caller: string, userSalt: string, queryHash: string, callbackHash: string, refundee: string): string;
export declare function encodeResult(sourceChainId: number | string | BigInt, dataResultsRoot: string, dataResultsPoseidonRoot: string, computeResultsHash: string): string;
export declare function getResultHash(result: AxiomV2Result): string;
export declare function getQuerySchemaHash(k: number | string | BigInt, resultLen: number | string | BigInt, vkey: string[]): string;
export declare function getDataQueryHash(sourceChainId: number | string | BigInt, subqueryHashes: string[]): string;
export declare function getDataQueryHashFromSubqueries(sourceChainId: number | string | BigInt, dataSubqueries: DataSubquery[]): string;
export declare function getSubqueryHash(type: DataSubqueryType, subqueryData: string): string;
/**
 * Encodes a full DataQuery
 * @param sourceChainId (uint64) chainId of the source chain
 * @param dataSubqueries (DataSubquery[]) an array of DataSubqueries to be encoded
 * @returns hex string of encoded query data
 */
export declare function encodeDataQuery(sourceChainId: number | string | BigInt, dataSubqueries: DataSubquery[]): string;
export declare function encodeDataSubquery(subquery: DataSubquery): string;
export declare function encodeQuerySchema(k: number | string | BigInt, resultLen: number | string | BigInt, vkey: string[]): string;
export declare function encodeComputeQuery(k: number | string | BigInt, resultLen: number | string | BigInt, vkey: string[], computeProof: string): string;
export declare function encodeCallback(target: string, extraData: string): string;
export declare function getCallbackHash(target: string, extraData: string): string;
export declare function encodeFeeData(maxFeePerGas: number | string | BigInt, callbackGasLimit: number | string | BigInt, overrideAxiomQueryFee: number | string | BigInt): string;
export declare function encodeSubquery(type: DataSubqueryType, encodedData: string): string;
export declare function encodeHeaderSubquery(blockNumber: number | string | BigInt, fieldIdx: number | string | BigInt): string;
export declare function encodeAccountSubquery(blockNumber: number | string | BigInt, addr: string, fieldIdx: number | string | BigInt): string;
export declare function encodeStorageSubquery(blockNumber: number | string | BigInt, addr: string, slot: number | string | BigInt): string;
export declare function encodeTxSubquery(blockNumber: number | string | BigInt, txIdx: number | string | BigInt, fieldOrCalldataIdx: number | string | BigInt): string;
export declare function encodeReceiptSubquery(blockNumber: number | string | BigInt, txIdx: number | string | BigInt, fieldOrLogIdx: number | string | BigInt, topicOrDataOrAddressIdx: number | string | BigInt, eventSchema: string): string;
export declare function encodeSolidityNestedMappingSubquery(blockNumber: number | string | BigInt, addr: string, mappingSlot: number | string | BigInt, mappingDepth: number | string | BigInt, keys: string[]): string;
export declare function encodeBeaconValidatorSubquery(): string;
