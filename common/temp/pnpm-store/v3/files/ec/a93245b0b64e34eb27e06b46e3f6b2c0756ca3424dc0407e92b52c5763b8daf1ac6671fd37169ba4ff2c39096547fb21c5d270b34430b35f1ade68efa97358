"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildDataSubquery = exports.buildDataQuery = exports.encodeBuilderDataQuery = exports.buildDataSubqueries = void 0;
const tools_1 = require("@axiom-crypto/tools");
const types_1 = require("../../types");
const utils_1 = require("./utils");
/**
 * Builds UnbuiltSubquery[] into DataSubquery[]
 */
async function buildDataSubqueries(provider, subqueries) {
    let dataSubqueries = [];
    for (const subquery of subqueries) {
        const type = (0, utils_1.getUnbuiltSubqueryTypeFromKeys)(Object.keys(subquery));
        let dataSubquery = await buildDataSubquery(provider, subquery, type);
        dataSubqueries.push(dataSubquery);
    }
    return dataSubqueries;
}
exports.buildDataSubqueries = buildDataSubqueries;
function encodeBuilderDataQuery(chainId, allSubqueries) {
    return (0, tools_1.encodeDataQuery)(chainId, allSubqueries);
}
exports.encodeBuilderDataQuery = encodeBuilderDataQuery;
function buildDataQuery(chainId, allSubqueries) {
    const sourceChainId = chainId.toString();
    return {
        sourceChainId,
        subqueries: allSubqueries,
    };
}
exports.buildDataQuery = buildDataQuery;
async function buildDataSubquery(provider, subquery, type) {
    switch (type) {
        case types_1.DataSubqueryType.Header:
            return buildDataSubqueryHeader(subquery);
        case types_1.DataSubqueryType.Account:
            return buildDataSubqueryAccount(subquery);
        case types_1.DataSubqueryType.Storage:
            return buildDataSubqueryStorage(subquery);
        case types_1.DataSubqueryType.Transaction:
            return buildDataSubqueryTx(provider, subquery);
        case types_1.DataSubqueryType.Receipt:
            return buildDataSubqueryReceipt(provider, subquery);
        case types_1.DataSubqueryType.SolidityNestedMapping:
            return buildDataSubquerySolidityNestedMapping(subquery);
        default:
            throw new Error(`Invalid data subquery type: ${type}`);
    }
}
exports.buildDataSubquery = buildDataSubquery;
async function buildDataSubqueryHeader(subquery) {
    return {
        type: types_1.DataSubqueryType.Header,
        subqueryData: {
            blockNumber: subquery.blockNumber,
            fieldIdx: subquery.fieldIdx,
        },
    };
}
async function buildDataSubqueryAccount(subquery) {
    return {
        type: types_1.DataSubqueryType.Account,
        subqueryData: {
            blockNumber: subquery.blockNumber,
            addr: subquery.addr.toLowerCase(),
            fieldIdx: subquery.fieldIdx,
        },
    };
}
async function buildDataSubqueryStorage(subquery) {
    return {
        type: types_1.DataSubqueryType.Storage,
        subqueryData: {
            blockNumber: subquery.blockNumber,
            addr: subquery.addr.toLowerCase(),
            slot: subquery.slot,
        },
    };
}
async function buildDataSubqueryTx(provider, subquery) {
    const { blockNumber, txIdx } = await (0, tools_1.getBlockNumberAndTxIdx)(provider, subquery.txHash);
    return {
        type: types_1.DataSubqueryType.Transaction,
        subqueryData: {
            blockNumber,
            txIdx,
            fieldOrCalldataIdx: subquery.fieldOrCalldataIdx,
        },
    };
}
async function buildDataSubqueryReceipt(provider, subquery) {
    const { blockNumber, txIdx } = await (0, tools_1.getBlockNumberAndTxIdx)(provider, subquery.txHash);
    return {
        type: types_1.DataSubqueryType.Receipt,
        subqueryData: {
            blockNumber,
            txIdx,
            fieldOrLogIdx: subquery.fieldOrLogIdx,
            topicOrDataOrAddressIdx: subquery.topicOrDataOrAddressIdx,
            eventSchema: subquery.eventSchema.toLowerCase(),
        },
    };
}
async function buildDataSubquerySolidityNestedMapping(subquery) {
    return {
        type: types_1.DataSubqueryType.SolidityNestedMapping,
        subqueryData: {
            blockNumber: subquery.blockNumber,
            addr: subquery.addr.toLowerCase(),
            mappingSlot: subquery.mappingSlot,
            mappingDepth: subquery.mappingDepth,
            keys: subquery.keys.map((key) => (0, tools_1.bytes32)(key.toLowerCase())),
        },
    };
}
//# sourceMappingURL=build.js.map