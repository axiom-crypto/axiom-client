"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSolidityNestedMappingSubquery = exports.buildReceiptSubquery = exports.buildTxSubquery = exports.buildStorageSubquery = exports.buildAccountSubquery = exports.buildHeaderSubquery = void 0;
const ethers_1 = require("ethers");
const tools_1 = require("@axiom-crypto/tools");
/**
 * Builder for a Header data subquery
 * @param blockNumber Block number to query
 */
const buildHeaderSubquery = (blockNumber) => {
    (0, tools_1.validateSize)(blockNumber, "uint32");
    const blockNumberNum = Number(blockNumber.toString());
    /**
     * End of the builder chain for a Header subquery. Specifies the HeaderField to query.
     * @param field HeaderField to query
     * @returns UnbuiltHeaderSubquery struct
     */
    const field = (field) => {
        return {
            blockNumber: blockNumberNum,
            fieldIdx: field,
        };
    };
    /**
     * End of the builder chain for a Header subquery. Specifies the logs bloom index to query.
     * @param logsBloomIdx Logs Bloom index (bytes as bytes32 array) to query
     * @returns UnbuiltHeaderSubquery struct
     */
    const logsBloom = (logsBloomIdx) => {
        if (logsBloomIdx < 0 || logsBloomIdx >= 8) {
            throw new Error("logsBloomIdx range is [0,8)");
        }
        return {
            blockNumber: blockNumberNum,
            fieldIdx: (0, tools_1.getFieldIdxHeaderLogsBloomIdx)(logsBloomIdx),
        };
    };
    return Object.freeze({
        field,
        logsBloom,
    });
};
exports.buildHeaderSubquery = buildHeaderSubquery;
/**
 * Builder for an Account data subquery
 * @param blockNumber Block number to query
 */
const buildAccountSubquery = (blockNumber) => {
    (0, tools_1.validateSize)(blockNumber, "uint32");
    /**
     * Continues building an Account subquery. Specifies the address to query.
     */
    const blockNumberNum = Number(blockNumber.toString());
    const address = (address) => {
        (0, tools_1.validateAddress)(address);
        /**
         * End of the builder chain for an Account subquery. Specifies the AccountField to
         * query.
         * @param field AccountField to query
         * @returns UnbuiltAccountSubquery struct
         */
        const field = (field) => {
            return {
                blockNumber: blockNumberNum,
                addr: address,
                fieldIdx: field,
            };
        };
        return Object.freeze({
            field,
        });
    };
    return Object.freeze({
        address,
    });
};
exports.buildAccountSubquery = buildAccountSubquery;
/**
 * Builder for a Storage data subquery
 * @param blockNumber Block number to query
 */
const buildStorageSubquery = (blockNumber) => {
    (0, tools_1.validateSize)(blockNumber, "uint32");
    const blockNumberNum = Number(blockNumber.toString());
    /**
     * Continues building a Storage subquery. Specifies the address to query.
     * @param address Address to query
     */
    const address = (address) => {
        (0, tools_1.validateAddress)(address);
        /**
         * End of the builder chain for a Storage subquery. Specifies the storage slot to
         * query.
         * @param slot Storage slot to query
         * @returns UnbuiltStorageSubquery struct
         */
        const slot = (slot) => {
            (0, tools_1.validateSize)(slot, "uint256");
            const slotStr = (0, tools_1.bytes32)(slot.toString());
            return {
                blockNumber: blockNumberNum,
                addr: address,
                slot: slotStr,
            };
        };
        return Object.freeze({
            slot,
        });
    };
    return Object.freeze({
        address,
    });
};
exports.buildStorageSubquery = buildStorageSubquery;
/**
 * Builder for a Transaction data subquery
 * @param txHash Transaction hash to query
 */
const buildTxSubquery = (txHash) => {
    (0, tools_1.validateBytes32)(txHash);
    /**
     * End of builder chain for a Transaction subquery.
     * @param field The TxField to query
     * @returns UnbuiltTxSubquery struct
     */
    const field = (field) => {
        return {
            txHash,
            fieldOrCalldataIdx: field,
        };
    };
    /**
     * End of the builder chain for a Transaction subquery. Specifies the calldata data index
     * (as an array of bytes32 after the 4-byte function selector) to query.
     * @param dataIdx Calldata index (bytes as bytes32 array) to query
     * @returns UnbuiltTxSubquery struct
     */
    const calldata = (dataIdx) => {
        (0, tools_1.validateSize)(dataIdx, "uint32");
        const dataIdxNum = Number(dataIdx.toString());
        return {
            txHash,
            fieldOrCalldataIdx: (0, tools_1.getFieldIdxTxCalldataIdx)(dataIdxNum),
        };
    };
    /**
     * End of the builder chain for a Transaction subquery. Specifies the contract data index
     * (as an array of bytes32) to query.
     * @param dataIdx Contract data index (bytes as bytes32 array) to query
     * @returns UnbuiltTxSubquery struct
     */
    const contractData = (dataIdx) => {
        (0, tools_1.validateSize)(dataIdx, "uint32");
        const dataIdxNum = Number(dataIdx.toString());
        return {
            txHash,
            fieldOrCalldataIdx: (0, tools_1.getFieldIdxTxContractDataIdx)(dataIdxNum),
        };
    };
    /**
     * End of the builder chain for a Transaction subquery. Queries the transaction type.
     * @returns UnbuiltTxSubquery struct
     */
    const txType = () => {
        return {
            txHash,
            fieldOrCalldataIdx: (0, tools_1.getFieldIdxTxType)(),
        };
    };
    /**
     * End of the builder chain for a Transaction subquery. Queries the block number.
     * @returns UnbuiltTxSubquery struct
     */
    const blockNumber = () => {
        return {
            txHash,
            fieldOrCalldataIdx: (0, tools_1.getFieldIdxTxBlockNumber)(),
        };
    };
    /**
     * End of the builder chain for a Transaction subquery. Queries the transaction index.
     * @returns UnbuiltTxSubquery struct
     */
    const txIndex = () => {
        return {
            txHash,
            fieldOrCalldataIdx: (0, tools_1.getFieldIdxTxIndex)(),
        };
    };
    /**
     * End of the builder chain for a Transaction subquery. Queries the function selector.
     * @returns UnbuiltTxSubquery struct
     */
    const functionSelector = () => {
        return {
            txHash,
            fieldOrCalldataIdx: (0, tools_1.getFieldIdxTxFunctionSelector)(),
        };
    };
    /**
     * End of the builder chain for a Transaction subquery. Queries the keccak256 hash of
     * the transaction's calldata.
     * @returns UnbuiltTxSubquery struct
     */
    const calldataHash = () => {
        return {
            txHash,
            fieldOrCalldataIdx: (0, tools_1.getFieldIdxTxCalldataHash)(),
        };
    };
    return Object.freeze({
        field,
        calldata,
        contractData,
        txType,
        blockNumber,
        txIndex,
        functionSelector,
        calldataHash,
    });
};
exports.buildTxSubquery = buildTxSubquery;
/**
 * Builder for a Receipt data subquery
 * @param txHash Transaction hash to query
 */
const buildReceiptSubquery = (txHash) => {
    (0, tools_1.validateBytes32)(txHash);
    /**
     * End of the builder chain for a Receipt subquery. Specifies the ReceiptField to query.
     * @param field
     * @returns UnbuiltReceiptSubquery struct
     */
    const field = (field) => {
        return {
            txHash,
            fieldOrLogIdx: field,
            topicOrDataOrAddressIdx: 0,
            eventSchema: ethers_1.ethers.ZeroHash,
        };
    };
    /**
     * End of the builder chain for a Receipt subquery. Specifies the logs bloom index to query.
     * @param logsBloomIdx Logs Bloom index (bytes as bytes32 array) to query
     * @returns UnbuiltReceiptSubquery struct
     */
    const logsBloom = (logsBloomIdx) => {
        if (logsBloomIdx < 0 || logsBloomIdx >= 8) {
            throw new Error("logsBloomIdx range is [0,8)");
        }
        return {
            txHash,
            fieldOrLogIdx: (0, tools_1.getFieldIdxReceiptLogsBloomIdx)(logsBloomIdx),
            topicOrDataOrAddressIdx: 0,
            eventSchema: ethers_1.ethers.ZeroHash,
        };
    };
    /**
     * Continues building a Receipt subquery for a log (event) index.
     * @param logIdx Index of the log event to query
     */
    const log = (logIdx) => {
        (0, tools_1.validateSize)(logIdx, "uint32");
        logIdx = (0, tools_1.getFieldIdxReceiptLogIdx)(logIdx);
        /**
         * Continues building a Receipt subquery. Specifies the topic index of the
         * log to query.
         * @param topicIdx Index of the topic to query
         */
        const topic = (topicIdx) => {
            (0, tools_1.validateSize)(topicIdx, "uint32");
            /**
             * End of the builder chain for a Receipt subquery. Specifies the event schema of the log.
             * @param eventSchema Bytes32 event schema
             * @returns UnbuiltReceiptSubquery struct
             */
            const eventSchema = (eventSchema) => {
                eventSchema = eventSchema.startsWith("0x") ? eventSchema : (0, tools_1.getEventSchema)(eventSchema);
                (0, tools_1.validateBytes32)(eventSchema);
                return {
                    txHash,
                    fieldOrLogIdx: logIdx,
                    topicOrDataOrAddressIdx: (0, tools_1.getFieldIdxReceiptTopicIdx)(topicIdx),
                    eventSchema,
                };
            };
            return Object.freeze({
                eventSchema,
            });
        };
        /**
         * Continues building a Receipt subquery. Specifies the data index of the
         * log to query.
         * @param dataIdx Index of the data to query (bytes as bytes32 array)
         */
        const data = (dataIdx) => {
            (0, tools_1.validateSize)(dataIdx, "uint32");
            /**
             * End of the builder chain for a Receipt subquery. Specifies the event schema of the log.
             * @param eventSchema Bytes32 event schema
             * @returns UnbuiltReceiptSubquery struct
             */
            const eventSchema = (eventSchema) => {
                eventSchema = eventSchema.startsWith("0x") ? eventSchema : (0, tools_1.getEventSchema)(eventSchema);
                (0, tools_1.validateBytes32)(eventSchema);
                return {
                    txHash,
                    fieldOrLogIdx: logIdx,
                    topicOrDataOrAddressIdx: (0, tools_1.getFieldIdxReceiptDataIdx)(dataIdx),
                    eventSchema,
                };
            };
            return Object.freeze({
                eventSchema,
            });
        };
        /**
         * End of the builder chain for a Receipt subquery. Specifies querying the address
         * of the log event.
         * @returns UnbuiltReceiptSubquery struct
         */
        const address = () => {
            return {
                txHash,
                fieldOrLogIdx: logIdx,
                topicOrDataOrAddressIdx: (0, tools_1.getFieldIdxReceiptLogAddress)(),
                eventSchema: ethers_1.ethers.ZeroHash,
            };
        };
        return Object.freeze({
            topic,
            data,
            address,
        });
    };
    /**
     * End of the builder chain for a Receipt subquery. Queries the transaction type.
     * @returns UnbuiltReceiptSubquery struct
     */
    const txType = () => {
        return {
            txHash,
            fieldOrLogIdx: (0, tools_1.getFieldIdxReceiptTxType)(),
            topicOrDataOrAddressIdx: 0,
            eventSchema: ethers_1.ethers.ZeroHash,
        };
    };
    /**
     * End of the builder chain for a Receipt subquery. Queries the block number.
     * @returns UnbuiltReceiptSubquery struct
     */
    const blockNumber = () => {
        return {
            txHash,
            fieldOrLogIdx: (0, tools_1.getFieldIdxReceiptBlockNumber)(),
            topicOrDataOrAddressIdx: 0,
            eventSchema: ethers_1.ethers.ZeroHash,
        };
    };
    /**
     * End of the builder chain for a Receipt subquery. Queries the transaction index.
     * @returns UnbuiltReceiptSubquery struct
     */
    const txIndex = () => {
        return {
            txHash,
            fieldOrLogIdx: (0, tools_1.getFieldIdxReceiptTxIndex)(),
            topicOrDataOrAddressIdx: 0,
            eventSchema: ethers_1.ethers.ZeroHash,
        };
    };
    return Object.freeze({
        field,
        logsBloom,
        log,
        txType,
        blockNumber,
        txIndex,
    });
};
exports.buildReceiptSubquery = buildReceiptSubquery;
/**
 * Builder for a Solidity Nested Mapping data subquery
 * @param blockNumber Block number to query
 */
const buildSolidityNestedMappingSubquery = (blockNumber) => {
    (0, tools_1.validateSize)(blockNumber, "uint32");
    const blockNumberNum = Number(blockNumber.toString());
    /**
     * Continues building a Solidity Nested Mapping subquery. Specifies the contract address
     * to query.
     * @param address Contract address to query
     */
    const address = (address) => {
        (0, tools_1.validateAddress)(address);
        /**
         * Continues building a Solidity Nested Mapping subquery. Specifies the slot of the
         * mapping in the contract.
         * @param mappingSlot Slot of the mapping in the contract to query.
         */
        const mappingSlot = (mappingSlot) => {
            (0, tools_1.validateSize)(mappingSlot, "uint256");
            const mappingSlotStr = (0, tools_1.bytes32)(mappingSlot.toString());
            /**
             * End of the builder chain for a Solidity Nested Mapping subquery. Specifies an array
             * of keys for the nested mapping. Max nested mappinng depth supported is 4.
             * @param keys An array of keys for the nested mapping (max depth 4).
             * @returns UnbuiltSolidityNestedMappingSubquery struct
             */
            const keys = (keys) => {
                if (keys.length > 4) {
                    throw new Error("Max mapping depth supported is 4");
                }
                const keysStr = keys.map(k => (0, tools_1.bytes32)(k.toString()));
                return {
                    blockNumber: blockNumberNum,
                    addr: address,
                    mappingSlot: mappingSlotStr,
                    mappingDepth: keys.length,
                    keys: keysStr,
                };
            };
            return Object.freeze({
                keys,
            });
        };
        return Object.freeze({
            mappingSlot,
        });
    };
    return Object.freeze({
        address,
    });
};
exports.buildSolidityNestedMappingSubquery = buildSolidityNestedMappingSubquery;
//# sourceMappingURL=subqueryBuilder.js.map